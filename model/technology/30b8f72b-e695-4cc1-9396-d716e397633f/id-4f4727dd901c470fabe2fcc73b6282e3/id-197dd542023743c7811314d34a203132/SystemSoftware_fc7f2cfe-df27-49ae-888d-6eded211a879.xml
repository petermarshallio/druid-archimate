<archimate:SystemSoftware
    xmlns:archimate="http://www.archimatetool.com/archimate"
    name="Broker"
    id="fc7f2cfe-df27-49ae-888d-6eded211a879"
    documentation="Divines and forwards query work to MiddleManagers / Historicals and merges results.&#xA;&#xA;These processes are stateless.&#xA;&#xA;There is one thread pool for all queries - druid.server.http.numThreads - one entry per query request / healthcheck.&#xA;&#xA;1) It handles SQL to Native Query translation in Apache Calcite [SqlLifecycle / PlannerFactory / SqlResource] and issues the native Druid version&#xA;&#xA;2) Jersey entrypoint for QueryResource / QueryLifecycle encapsulates authorisation (table based by looking at the datasources - boolean decision), issuing the query itself and collecting the results, and emitting metrics and logs&#xA;&#xA;3) ClientQuerySegmentWalker does subquery inlining (recursively), and determines the local (LocalQuerySegmentWalker = runs on the broker - inline data) vs cluster runner (CachingClusteredClient = on data processes - druid tables) jobs for each query and subquery&#xA;&#xA;4) CachineClusteredClient prunes the segments required, and then fans out the jobs to the data servers, able to determine which boxes contain the data it needs to query on partitions - ie time and secondary partitions on some dim from shardSpecs.  A connection from the druid.broker.http.numConnections is taken up for every connection to a data server that the query needs to contact.&#xA;&#xA;5) Results are merged in merge buffers - druid.processing.numMergeBuffers for GROUP BY operations and when subqueries are involved, one buffer per query&#xA;&#xA;ServerView and InventoryView monitor the announcements - along with DruidNodeDiscoveryProvider&#xA;&#xA;In code, &quot;client&quot; usually refers to the broker, and &quot;server&quot; usually refers to the data servers"/>
