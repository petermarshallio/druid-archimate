<archimate:Node
    xmlns:archimate="http://www.archimatetool.com/archimate"
    name="Historical"
    id="id-605a049d101748279862c29ab3589e33"
    documentation="Stores and processes published data to return statistics, and will consume all available resources as it answers each individual query (unlike the Broker).&#xA;&#xA;These servers scale according to how much older data there is.&#xA;&#xA;Has the same Jersey entrypoint for QueryResource / QueryLifecycle that encapsulates authorisation (table based by looking at the datasources - boolean decision), issuing the query itself and collecting the results, and emitting metrics and logs.&#xA;&#xA;Like the broker, they also have druid.server.http.numThreads limit on the number of incoming queries.&#xA;&#xA;But this time it goes to ServerManager, which maps queries on to units of per-segment work that is queued up into a thread pool (druid.processing.numThreads) - see QueryRunnerFactory and QueryToolChest which take a query and a set of segments and figure out what has to be done and then generates the actual runnables.&#xA;&#xA;The threadpool is priorised by priority preempted based on small items of work.&#xA;&#xA;In code, the LoadQueuePeon is the process that tells Historicals to load and drop segments (on the coordinator???)&#xA;&#xA;Bottlenecks can occur here in processing queries if segment scan time is high (the processing thread itself - where there is one per processor as it churns through one segment at a time from a work list) or in the number of Jetty threads.&#xA;&#xA;The query processing thread here (a) opens all segments matching the time filter, (b) applies WHERE filters, (c) carries out GROUP BY calculations, and (d) applies ORDER and LIMIT (if pushed down to individual segments).  Step (d) is usually applied here for approximate calculations.&#xA;&#xA;There are also merge buffers (like the broker) for the exact same purposes.  It (a) receives results from all local processing threads on this server, (b) applies ORDER and LIMIT (if pushed down), and (c) passes results back to the Broker.  When this becomes the bottleneck in query processing, it's possible that smaller servers (=> fewer query processing threads) may be beneficial.  This can be seen in flame graphs."/>
